# React

- [Общие вопросы](#Общие-вопросы)
- [Базовые вопросы](#Базовые-вопросы)
- [Продвинутые вопросы](#Продвинутые-вопросы)

## Общие вопросы

### Что такое Virtual DOM?

Это клон объектного представления DOM, которые позволяет вносить изменения в настоящую
DOM более производительно за счет того, что мы можем свободно и часто манипулировать
этим клоном, не касаясь реальной DOM, пока нам это не понадобится.
Отличия от реальной DOM:
- Реальная DOM может обновлять HTML, VDOM - нет
- Настоящая DOM создает полную перерисовку при обновлении. Виртуальная модель DOM
  действует как копия реальной модели DOM, которая прослушивает обновления
  состояния и вычисляет различия с предыдущей VDOM, так что она может перерисовать
  только те узлы, которые изменились
- Настоящая DOM - это объектное представление HTML-документа + интерфейс для управления
  этим объектом. VDOM - это шаблон, который по-разному реализуется в разных технологиях


### Что такое Shadow DOM?

Это теневая DOM, что-то вроде DOM в DOM, созданная для скрытия элементов, инкапсуляции
стилей. Недоступна для обращения стандартным способом с помощью JS


## Базовые вопросы

### Как обновить состояние на основе предыдущего состояния?

```javascript
this.setState((prevState, props) => {
    return {
        streak: prevState.streak + props.count,
    };
});
```

```javascript
const [state, setState] = useState(0);

setState(prevState => prevState + 1);
setState(prevState => prevState + 1);
```


### Что такое keys в React и в чем их важность?

Keys (ключи) помогают React отследить какие элементы были изменены, добавлены или
удалены из списка.
Важно, чтобы каждый ключ был уникальным между "собратьями"


### Как можно создать и передать обработчик события?

1. Биндинг в конструкторе
2. Метод как стрелочная функция
3. Передача стрелочной функции-коллбэк как проп элемента
4. Передача метода как проп с биндингом


### Когда и почему нужно делать Ajax запрос в компоненте?

`componentDidMount() `или `useEffect()`, потому что:
Мы не можем гарантировать, что AJAX-запрос не будет разрешен (resolve) перед моментом
монтирования компонента. Если да, то это будет означать, что вы пытаетесь выполнить
`setState` над демонтированным компонентом и мы обязательно получим сообщение об этом
от React. А так мы гарантируем, что компонент для обновления присутствует.
Если же нам не нужно менять состояние, то можно вызвать и в `UNSAFE_componentWillMount()`
или в любом месте функционального компонента


### Как обновить состояние на основе props?

`getDerivedStateFromProps(props, state)` вызывается непосредственно перед вызовом метода
рендеринга как при первоначальном монтировании, так и при последующих обновлениях.
Он должен возвращать объект, чтобы обновить состояние, или null, чтобы ничего не обновлять.
В функциональных компонентах можно значение из `props` сразу класть в `useState()`


### Что такое компонент высшего порядка и зачем он нужен?

Компонент высшего порядка — это функция, которая принимает компонент и возвращает
новый компонент.
КВП (HOC) позволяют абстрагировать общую для компонентов логику в один главный компонент


### Расскажите про хуки

`useState()`

- Нельзя вызывать по условию
- Сеттер (обновление состояния) работает асинхронно, может принимать callback с предыдущим состоянием
- Вычисляемое начальное состояние можно закешировать передав в `useState` callback
- Если состояние является объектом, то при изменении состояния нужно передавать весь объект

`useEffect()`

- Без зависимостей вызывается при каждом рендере
- Во второй параметр можно передать массив зависимостей, тогда вызов будет при их изменении
- Передача пустого массива зависимостей создает поведение метода `componentDidMount`
- Можно вернуть функцию, которая создаст поведение метода `componentWillUnmount`
- При наличии зависимостей возвращаемая функция тоже будет срабатывать при их изменениях
- Основная мысль: Синхронизация, а не жизненный цикл

`useRef()`

- Сохраняет состояние между рендерами
- Изменения не вызывают рендер
- Можно получить ссылку на элемент DOM

`useMemo()`

- Используется для кеширования каких-то вычисляемых значений, которые не должны вычисляться заново
  из-за других изменений

`useCallback()`

- Используется для кеширования созданной в компоненте функции, которая не должна пересоздаваться
  при изменении других зависимостей

`useContext()`

- Заменяет `React.Context`
- Можно создать функцию, возвращающую контекст, и `Provider`, который передает объект данных, чтобы
  передаваемые данные получать через деструктуризацию

`useReducer()`

- Взаимодействует с состоянием
- Работает как в Redux, только состояние создается в компоненте и прокидывается через контекст

`useLayoutEffect()`

- Работает как `useEffect()`, но отрабатывает синхронно после всех изменений DOM, игнорируя
  информацию об отрисовке


## Продвинутые вопросы

### Каким типом данных может быть свойство children у компонентов?

Объект (фрагмент или один элемент), массив (список), функция (Render Props)
Для безопасного использования `children.map(...)` нужно использовать:

```javascript
React.Children.map(children, arg => {})
```


### Когда полезно применять Context API?

...


### Что такое портал?

Это позволяет вырваться из корневого элемента, в котором действует `ReactDOM.render`.
Он позволяет отображать дочерние элементы в узле DOM, который существует вне иерархии
DOM родительского компонента. Используйте для всплывающих подсказок, модальных окон,
уведомлений...


### Как рендерить большие списки?

...


### Как профилировать приложение на React?

...
